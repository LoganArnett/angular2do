{"version":3,"sources":["@traceur/generated/TemplateParser/6","@traceur/generated/TemplateParser/5","text_interpolation_parser_spec.js","@traceur/generated/TemplateParser/167","@traceur/generated/TemplateParser/4","@traceur/generated/TemplateParser/3","@traceur/generated/TemplateParser/13"],"names":[],"mappings":"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","file":"/Users/patrick/Documents/open source/angular/modules/angular2/test/core/compiler/pipeline/text_interpolation_parser_spec.js","sourceRoot":"/Users/patrick/Documents/open source/angular/modules/angular2/test/core/compiler/pipeline/","sourcesContent":["System.register($__placeholder__0, $__placeholder__1, function($__export) {\n          $__placeholder__2\n        });","var __moduleName = $__placeholder__0;","import {describe, beforeEach, expect, it, iit, ddescribe, el} from 'angular2/test_lib';\nimport {TextInterpolationParser} from 'angular2/src/core/compiler/pipeline/text_interpolation_parser';\nimport {CompilePipeline} from 'angular2/src/core/compiler/pipeline/compile_pipeline';\nimport {DOM} from 'angular2/src/facade/dom';\nimport {MapWrapper} from 'angular2/src/facade/collection';\n\nimport {Lexer, Parser} from 'angular2/change_detection';\nimport {IgnoreChildrenStep} from './pipeline_spec';\n\nexport function main() {\n  describe('TextInterpolationParser', () => {\n    function createPipeline() {\n      return new CompilePipeline([\n        new IgnoreChildrenStep(),\n        new TextInterpolationParser(new Parser(new Lexer()), null)\n      ]);\n    }\n\n    it('should find text interpolation in normal elements', () => {\n      var results = createPipeline().process(el('<div>{{expr1}}<span></span>{{expr2}}</div>'));\n      var bindings = results[0].textNodeBindings;\n      expect(MapWrapper.get(bindings, 0).source).toEqual(\"{{expr1}}\");\n      expect(MapWrapper.get(bindings, 2).source).toEqual(\"{{expr2}}\");\n    });\n\n    it('should find text interpolation in template elements', () => {\n      var results = createPipeline().process(el('<template>{{expr1}}<span></span>{{expr2}}</template>'));\n      var bindings = results[0].textNodeBindings;\n      expect(MapWrapper.get(bindings, 0).source).toEqual(\"{{expr1}}\");\n      expect(MapWrapper.get(bindings, 2).source).toEqual(\"{{expr2}}\");\n    });\n\n    it('should allow multiple expressions', () => {\n      var results = createPipeline().process(el('<div>{{expr1}}{{expr2}}</div>'));\n      var bindings = results[0].textNodeBindings;\n      expect(MapWrapper.get(bindings, 0).source).toEqual(\"{{expr1}}{{expr2}}\");\n    });\n\n    it('should not interpolate when compileChildren is false', () => {\n      var results = createPipeline().process(el('<div>{{included}}<span ignore-children>{{excluded}}</span></div>'));\n      var bindings = results[0].textNodeBindings;\n      expect(MapWrapper.get(bindings, 0).source).toEqual(\"{{included}}\");\n      expect(results[1].textNodeBindings).toBe(null);\n    });\n\n    it('should allow fixed text before, in between and after expressions', () => {\n      var results = createPipeline().process(el('<div>a{{expr1}}b{{expr2}}c</div>'));\n      var bindings = results[0].textNodeBindings;\n      expect(MapWrapper.get(bindings, 0).source).toEqual(\"a{{expr1}}b{{expr2}}c\");\n    });\n\n    it('should escape quotes in fixed parts', () => {\n      var results = createPipeline().process(el(\"<div>'\\\"a{{expr1}}</div>\"));\n      expect(MapWrapper.get(results[0].textNodeBindings, 0).source).toEqual(\"'\\\"a{{expr1}}\");\n    });\n  });\n}\n","\n        $__export($__placeholder__0, $__placeholder__1)\n      ","return {\n      setters: $__placeholder__0,\n      execute: $__placeholder__1\n    }","function($__m) {\n          $__placeholder__0\n        }","$__placeholder__0 = $__m.$__placeholder__1;"]}